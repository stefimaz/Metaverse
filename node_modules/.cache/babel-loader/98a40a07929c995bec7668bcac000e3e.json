{"ast":null,"code":"/**\n * @webxr-input-profiles/motion-controllers 1.0.0 https://github.com/immersive-web/webxr-input-profiles\n */\nconst MotionControllerConstants = {\n  Handedness: Object.freeze({\n    NONE: 'none',\n    LEFT: 'left',\n    RIGHT: 'right'\n  }),\n  ComponentState: Object.freeze({\n    DEFAULT: 'default',\n    TOUCHED: 'touched',\n    PRESSED: 'pressed'\n  }),\n  ComponentProperty: Object.freeze({\n    BUTTON: 'button',\n    X_AXIS: 'xAxis',\n    Y_AXIS: 'yAxis',\n    STATE: 'state'\n  }),\n  ComponentType: Object.freeze({\n    TRIGGER: 'trigger',\n    SQUEEZE: 'squeeze',\n    TOUCHPAD: 'touchpad',\n    THUMBSTICK: 'thumbstick',\n    BUTTON: 'button'\n  }),\n  ButtonTouchThreshold: 0.05,\n  AxisTouchThreshold: 0.1,\n  VisualResponseProperty: Object.freeze({\n    TRANSFORM: 'transform',\n    VISIBILITY: 'visibility'\n  })\n};\n/**\n * @description Static helper function to fetch a JSON file and turn it into a JS object\n * @param {string} path - Path to JSON file to be fetched\n */\n\nasync function fetchJsonFile(path) {\n  const response = await fetch(path);\n\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  } else {\n    return response.json();\n  }\n}\n\nasync function fetchProfilesList(basePath) {\n  if (!basePath) {\n    throw new Error('No basePath supplied');\n  }\n\n  const profileListFileName = 'profilesList.json';\n  const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);\n  return profilesList;\n}\n\nasync function fetchProfile(xrInputSource, basePath) {\n  let defaultProfile = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let getAssetPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n  if (!xrInputSource) {\n    throw new Error('No xrInputSource supplied');\n  }\n\n  if (!basePath) {\n    throw new Error('No basePath supplied');\n  } // Get the list of profiles\n\n\n  const supportedProfilesList = await fetchProfilesList(basePath); // Find the relative path to the first requested profile that is recognized\n\n  let match;\n  xrInputSource.profiles.some(profileId => {\n    const supportedProfile = supportedProfilesList[profileId];\n\n    if (supportedProfile) {\n      match = {\n        profileId,\n        profilePath: `${basePath}/${supportedProfile.path}`,\n        deprecated: !!supportedProfile.deprecated\n      };\n    }\n\n    return !!match;\n  });\n\n  if (!match) {\n    if (!defaultProfile) {\n      throw new Error('No matching profile name found');\n    }\n\n    const supportedProfile = supportedProfilesList[defaultProfile];\n\n    if (!supportedProfile) {\n      throw new Error(`No matching profile name found and default profile \"${defaultProfile}\" missing.`);\n    }\n\n    match = {\n      profileId: defaultProfile,\n      profilePath: `${basePath}/${supportedProfile.path}`,\n      deprecated: !!supportedProfile.deprecated\n    };\n  }\n\n  const profile = await fetchJsonFile(match.profilePath);\n  let assetPath;\n\n  if (getAssetPath) {\n    let layout;\n\n    if (xrInputSource.handedness === 'any') {\n      layout = profile.layouts[Object.keys(profile.layouts)[0]];\n    } else {\n      layout = profile.layouts[xrInputSource.handedness];\n    }\n\n    if (!layout) {\n      throw new Error(`No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`);\n    }\n\n    if (layout.assetPath) {\n      assetPath = match.profilePath.replace('profile.json', layout.assetPath);\n    }\n  }\n\n  return {\n    profile,\n    assetPath\n  };\n}\n/** @constant {Object} */\n\n\nconst defaultComponentValues = {\n  xAxis: 0,\n  yAxis: 0,\n  button: 0,\n  state: MotionControllerConstants.ComponentState.DEFAULT\n};\n/**\n * @description Converts an X, Y coordinate from the range -1 to 1 (as reported by the Gamepad\n * API) to the range 0 to 1 (for interpolation). Also caps the X, Y values to be bounded within\n * a circle. This ensures that thumbsticks are not animated outside the bounds of their physical\n * range of motion and touchpads do not report touch locations off their physical bounds.\n * @param {number} x The original x coordinate in the range -1 to 1\n * @param {number} y The original y coordinate in the range -1 to 1\n */\n\nfunction normalizeAxes() {\n  let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let xAxis = x;\n  let yAxis = y; // Determine if the point is outside the bounds of the circle\n  // and, if so, place it on the edge of the circle\n\n  const hypotenuse = Math.sqrt(x * x + y * y);\n\n  if (hypotenuse > 1) {\n    const theta = Math.atan2(y, x);\n    xAxis = Math.cos(theta);\n    yAxis = Math.sin(theta);\n  } // Scale and move the circle so values are in the interpolation range.  The circle's origin moves\n  // from (0, 0) to (0.5, 0.5). The circle's radius scales from 1 to be 0.5.\n\n\n  const result = {\n    normalizedXAxis: xAxis * 0.5 + 0.5,\n    normalizedYAxis: yAxis * 0.5 + 0.5\n  };\n  return result;\n}\n/**\n * Contains the description of how the 3D model should visually respond to a specific user input.\n * This is accomplished by initializing the object with the name of a node in the 3D model and\n * property that need to be modified in response to user input, the name of the nodes representing\n * the allowable range of motion, and the name of the input which triggers the change. In response\n * to the named input changing, this object computes the appropriate weighting to use for\n * interpolating between the range of motion nodes.\n */\n\n\nclass VisualResponse {\n  constructor(visualResponseDescription) {\n    this.componentProperty = visualResponseDescription.componentProperty;\n    this.states = visualResponseDescription.states;\n    this.valueNodeName = visualResponseDescription.valueNodeName;\n    this.valueNodeProperty = visualResponseDescription.valueNodeProperty;\n\n    if (this.valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM) {\n      this.minNodeName = visualResponseDescription.minNodeName;\n      this.maxNodeName = visualResponseDescription.maxNodeName;\n    } // Initializes the response's current value based on default data\n\n\n    this.value = 0;\n    this.updateFromComponent(defaultComponentValues);\n  }\n  /**\n   * Computes the visual response's interpolation weight based on component state\n   * @param {Object} componentValues - The component from which to update\n   * @param {number} xAxis - The reported X axis value of the component\n   * @param {number} yAxis - The reported Y axis value of the component\n   * @param {number} button - The reported value of the component's button\n   * @param {string} state - The component's active state\n   */\n\n\n  updateFromComponent(_ref) {\n    let {\n      xAxis,\n      yAxis,\n      button,\n      state\n    } = _ref;\n    const {\n      normalizedXAxis,\n      normalizedYAxis\n    } = normalizeAxes(xAxis, yAxis);\n\n    switch (this.componentProperty) {\n      case MotionControllerConstants.ComponentProperty.X_AXIS:\n        this.value = this.states.includes(state) ? normalizedXAxis : 0.5;\n        break;\n\n      case MotionControllerConstants.ComponentProperty.Y_AXIS:\n        this.value = this.states.includes(state) ? normalizedYAxis : 0.5;\n        break;\n\n      case MotionControllerConstants.ComponentProperty.BUTTON:\n        this.value = this.states.includes(state) ? button : 0;\n        break;\n\n      case MotionControllerConstants.ComponentProperty.STATE:\n        if (this.valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY) {\n          this.value = this.states.includes(state);\n        } else {\n          this.value = this.states.includes(state) ? 1.0 : 0.0;\n        }\n\n        break;\n\n      default:\n        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);\n    }\n  }\n\n}\n\nclass Component {\n  /**\n   * @param {Object} componentId - Id of the component\n   * @param {Object} componentDescription - Description of the component to be created\n   */\n  constructor(componentId, componentDescription) {\n    if (!componentId || !componentDescription || !componentDescription.visualResponses || !componentDescription.gamepadIndices || Object.keys(componentDescription.gamepadIndices).length === 0) {\n      throw new Error('Invalid arguments supplied');\n    }\n\n    this.id = componentId;\n    this.type = componentDescription.type;\n    this.rootNodeName = componentDescription.rootNodeName;\n    this.touchPointNodeName = componentDescription.touchPointNodeName; // Build all the visual responses for this component\n\n    this.visualResponses = {};\n    Object.keys(componentDescription.visualResponses).forEach(responseName => {\n      const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);\n      this.visualResponses[responseName] = visualResponse;\n    }); // Set default values\n\n    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);\n    this.values = {\n      state: MotionControllerConstants.ComponentState.DEFAULT,\n      button: this.gamepadIndices.button !== undefined ? 0 : undefined,\n      xAxis: this.gamepadIndices.xAxis !== undefined ? 0 : undefined,\n      yAxis: this.gamepadIndices.yAxis !== undefined ? 0 : undefined\n    };\n  }\n\n  get data() {\n    const data = {\n      id: this.id,\n      ...this.values\n    };\n    return data;\n  }\n  /**\n   * @description Poll for updated data based on current gamepad state\n   * @param {Object} gamepad - The gamepad object from which the component data should be polled\n   */\n\n\n  updateFromGamepad(gamepad) {\n    // Set the state to default before processing other data sources\n    this.values.state = MotionControllerConstants.ComponentState.DEFAULT; // Get and normalize button\n\n    if (this.gamepadIndices.button !== undefined && gamepad.buttons.length > this.gamepadIndices.button) {\n      const gamepadButton = gamepad.buttons[this.gamepadIndices.button];\n      this.values.button = gamepadButton.value;\n      this.values.button = this.values.button < 0 ? 0 : this.values.button;\n      this.values.button = this.values.button > 1 ? 1 : this.values.button; // Set the state based on the button\n\n      if (gamepadButton.pressed || this.values.button === 1) {\n        this.values.state = MotionControllerConstants.ComponentState.PRESSED;\n      } else if (gamepadButton.touched || this.values.button > MotionControllerConstants.ButtonTouchThreshold) {\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED;\n      }\n    } // Get and normalize x axis value\n\n\n    if (this.gamepadIndices.xAxis !== undefined && gamepad.axes.length > this.gamepadIndices.xAxis) {\n      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];\n      this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis;\n      this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis; // If the state is still default, check if the xAxis makes it touched\n\n      if (this.values.state === MotionControllerConstants.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > MotionControllerConstants.AxisTouchThreshold) {\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED;\n      }\n    } // Get and normalize Y axis value\n\n\n    if (this.gamepadIndices.yAxis !== undefined && gamepad.axes.length > this.gamepadIndices.yAxis) {\n      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];\n      this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis;\n      this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis; // If the state is still default, check if the yAxis makes it touched\n\n      if (this.values.state === MotionControllerConstants.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > MotionControllerConstants.AxisTouchThreshold) {\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED;\n      }\n    } // Update the visual response weights based on the current component data\n\n\n    Object.values(this.visualResponses).forEach(visualResponse => {\n      visualResponse.updateFromComponent(this.values);\n    });\n  }\n\n}\n/**\n * @description Builds a motion controller with components and visual responses based on the\n * supplied profile description. Data is polled from the xrInputSource's gamepad.\n * @author Nell Waliczek / https://github.com/NellWaliczek\n */\n\n\nclass MotionController {\n  /**\n   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around\n   * @param {Object} profile - The best matched profile description for the supplied xrInputSource\n   * @param {Object} assetUrl\n   */\n  constructor(xrInputSource, profile, assetUrl) {\n    if (!xrInputSource) {\n      throw new Error('No xrInputSource supplied');\n    }\n\n    if (!profile) {\n      throw new Error('No profile supplied');\n    }\n\n    this.xrInputSource = xrInputSource;\n    this.assetUrl = assetUrl;\n    this.id = profile.profileId; // Build child components as described in the profile description\n\n    this.layoutDescription = profile.layouts[xrInputSource.handedness];\n    this.components = {};\n    Object.keys(this.layoutDescription.components).forEach(componentId => {\n      const componentDescription = this.layoutDescription.components[componentId];\n      this.components[componentId] = new Component(componentId, componentDescription);\n    }); // Initialize components based on current gamepad state\n\n    this.updateFromGamepad();\n  }\n\n  get gripSpace() {\n    return this.xrInputSource.gripSpace;\n  }\n\n  get targetRaySpace() {\n    return this.xrInputSource.targetRaySpace;\n  }\n  /**\n   * @description Returns a subset of component data for simplified debugging\n   */\n\n\n  get data() {\n    const data = [];\n    Object.values(this.components).forEach(component => {\n      data.push(component.data);\n    });\n    return data;\n  }\n  /**\n   * @description Poll for updated data based on current gamepad state\n   */\n\n\n  updateFromGamepad() {\n    Object.values(this.components).forEach(component => {\n      component.updateFromGamepad(this.xrInputSource.gamepad);\n    });\n  }\n\n}\n\nexport { MotionController, MotionControllerConstants, fetchProfile, fetchProfilesList };","map":{"version":3,"sources":["/Users/stephanemasyn/Desktop/FinTech/GitHub/Metaverse/node_modules/three-stdlib/libs/MotionControllers.js"],"names":["MotionControllerConstants","Handedness","Object","freeze","NONE","LEFT","RIGHT","ComponentState","DEFAULT","TOUCHED","PRESSED","ComponentProperty","BUTTON","X_AXIS","Y_AXIS","STATE","ComponentType","TRIGGER","SQUEEZE","TOUCHPAD","THUMBSTICK","ButtonTouchThreshold","AxisTouchThreshold","VisualResponseProperty","TRANSFORM","VISIBILITY","fetchJsonFile","path","response","fetch","ok","Error","statusText","json","fetchProfilesList","basePath","profileListFileName","profilesList","fetchProfile","xrInputSource","defaultProfile","getAssetPath","supportedProfilesList","match","profiles","some","profileId","supportedProfile","profilePath","deprecated","profile","assetPath","layout","handedness","layouts","keys","replace","defaultComponentValues","xAxis","yAxis","button","state","normalizeAxes","x","y","hypotenuse","Math","sqrt","theta","atan2","cos","sin","result","normalizedXAxis","normalizedYAxis","VisualResponse","constructor","visualResponseDescription","componentProperty","states","valueNodeName","valueNodeProperty","minNodeName","maxNodeName","value","updateFromComponent","includes","Component","componentId","componentDescription","visualResponses","gamepadIndices","length","id","type","rootNodeName","touchPointNodeName","forEach","responseName","visualResponse","assign","values","undefined","data","updateFromGamepad","gamepad","buttons","gamepadButton","pressed","touched","axes","abs","MotionController","assetUrl","layoutDescription","components","gripSpace","targetRaySpace","component","push"],"mappings":"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","sourcesContent":["/**\n * @webxr-input-profiles/motion-controllers 1.0.0 https://github.com/immersive-web/webxr-input-profiles\n */\nconst MotionControllerConstants = {\n  Handedness: Object.freeze({\n    NONE: 'none',\n    LEFT: 'left',\n    RIGHT: 'right'\n  }),\n  ComponentState: Object.freeze({\n    DEFAULT: 'default',\n    TOUCHED: 'touched',\n    PRESSED: 'pressed'\n  }),\n  ComponentProperty: Object.freeze({\n    BUTTON: 'button',\n    X_AXIS: 'xAxis',\n    Y_AXIS: 'yAxis',\n    STATE: 'state'\n  }),\n  ComponentType: Object.freeze({\n    TRIGGER: 'trigger',\n    SQUEEZE: 'squeeze',\n    TOUCHPAD: 'touchpad',\n    THUMBSTICK: 'thumbstick',\n    BUTTON: 'button'\n  }),\n  ButtonTouchThreshold: 0.05,\n  AxisTouchThreshold: 0.1,\n  VisualResponseProperty: Object.freeze({\n    TRANSFORM: 'transform',\n    VISIBILITY: 'visibility'\n  })\n};\n/**\n * @description Static helper function to fetch a JSON file and turn it into a JS object\n * @param {string} path - Path to JSON file to be fetched\n */\n\nasync function fetchJsonFile(path) {\n  const response = await fetch(path);\n\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  } else {\n    return response.json();\n  }\n}\n\nasync function fetchProfilesList(basePath) {\n  if (!basePath) {\n    throw new Error('No basePath supplied');\n  }\n\n  const profileListFileName = 'profilesList.json';\n  const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);\n  return profilesList;\n}\n\nasync function fetchProfile(xrInputSource, basePath, defaultProfile = null, getAssetPath = true) {\n  if (!xrInputSource) {\n    throw new Error('No xrInputSource supplied');\n  }\n\n  if (!basePath) {\n    throw new Error('No basePath supplied');\n  } // Get the list of profiles\n\n\n  const supportedProfilesList = await fetchProfilesList(basePath); // Find the relative path to the first requested profile that is recognized\n\n  let match;\n  xrInputSource.profiles.some(profileId => {\n    const supportedProfile = supportedProfilesList[profileId];\n\n    if (supportedProfile) {\n      match = {\n        profileId,\n        profilePath: `${basePath}/${supportedProfile.path}`,\n        deprecated: !!supportedProfile.deprecated\n      };\n    }\n\n    return !!match;\n  });\n\n  if (!match) {\n    if (!defaultProfile) {\n      throw new Error('No matching profile name found');\n    }\n\n    const supportedProfile = supportedProfilesList[defaultProfile];\n\n    if (!supportedProfile) {\n      throw new Error(`No matching profile name found and default profile \"${defaultProfile}\" missing.`);\n    }\n\n    match = {\n      profileId: defaultProfile,\n      profilePath: `${basePath}/${supportedProfile.path}`,\n      deprecated: !!supportedProfile.deprecated\n    };\n  }\n\n  const profile = await fetchJsonFile(match.profilePath);\n  let assetPath;\n\n  if (getAssetPath) {\n    let layout;\n\n    if (xrInputSource.handedness === 'any') {\n      layout = profile.layouts[Object.keys(profile.layouts)[0]];\n    } else {\n      layout = profile.layouts[xrInputSource.handedness];\n    }\n\n    if (!layout) {\n      throw new Error(`No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`);\n    }\n\n    if (layout.assetPath) {\n      assetPath = match.profilePath.replace('profile.json', layout.assetPath);\n    }\n  }\n\n  return {\n    profile,\n    assetPath\n  };\n}\n/** @constant {Object} */\n\n\nconst defaultComponentValues = {\n  xAxis: 0,\n  yAxis: 0,\n  button: 0,\n  state: MotionControllerConstants.ComponentState.DEFAULT\n};\n/**\n * @description Converts an X, Y coordinate from the range -1 to 1 (as reported by the Gamepad\n * API) to the range 0 to 1 (for interpolation). Also caps the X, Y values to be bounded within\n * a circle. This ensures that thumbsticks are not animated outside the bounds of their physical\n * range of motion and touchpads do not report touch locations off their physical bounds.\n * @param {number} x The original x coordinate in the range -1 to 1\n * @param {number} y The original y coordinate in the range -1 to 1\n */\n\nfunction normalizeAxes(x = 0, y = 0) {\n  let xAxis = x;\n  let yAxis = y; // Determine if the point is outside the bounds of the circle\n  // and, if so, place it on the edge of the circle\n\n  const hypotenuse = Math.sqrt(x * x + y * y);\n\n  if (hypotenuse > 1) {\n    const theta = Math.atan2(y, x);\n    xAxis = Math.cos(theta);\n    yAxis = Math.sin(theta);\n  } // Scale and move the circle so values are in the interpolation range.  The circle's origin moves\n  // from (0, 0) to (0.5, 0.5). The circle's radius scales from 1 to be 0.5.\n\n\n  const result = {\n    normalizedXAxis: xAxis * 0.5 + 0.5,\n    normalizedYAxis: yAxis * 0.5 + 0.5\n  };\n  return result;\n}\n/**\n * Contains the description of how the 3D model should visually respond to a specific user input.\n * This is accomplished by initializing the object with the name of a node in the 3D model and\n * property that need to be modified in response to user input, the name of the nodes representing\n * the allowable range of motion, and the name of the input which triggers the change. In response\n * to the named input changing, this object computes the appropriate weighting to use for\n * interpolating between the range of motion nodes.\n */\n\n\nclass VisualResponse {\n  constructor(visualResponseDescription) {\n    this.componentProperty = visualResponseDescription.componentProperty;\n    this.states = visualResponseDescription.states;\n    this.valueNodeName = visualResponseDescription.valueNodeName;\n    this.valueNodeProperty = visualResponseDescription.valueNodeProperty;\n\n    if (this.valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM) {\n      this.minNodeName = visualResponseDescription.minNodeName;\n      this.maxNodeName = visualResponseDescription.maxNodeName;\n    } // Initializes the response's current value based on default data\n\n\n    this.value = 0;\n    this.updateFromComponent(defaultComponentValues);\n  }\n  /**\n   * Computes the visual response's interpolation weight based on component state\n   * @param {Object} componentValues - The component from which to update\n   * @param {number} xAxis - The reported X axis value of the component\n   * @param {number} yAxis - The reported Y axis value of the component\n   * @param {number} button - The reported value of the component's button\n   * @param {string} state - The component's active state\n   */\n\n\n  updateFromComponent({\n    xAxis,\n    yAxis,\n    button,\n    state\n  }) {\n    const {\n      normalizedXAxis,\n      normalizedYAxis\n    } = normalizeAxes(xAxis, yAxis);\n\n    switch (this.componentProperty) {\n      case MotionControllerConstants.ComponentProperty.X_AXIS:\n        this.value = this.states.includes(state) ? normalizedXAxis : 0.5;\n        break;\n\n      case MotionControllerConstants.ComponentProperty.Y_AXIS:\n        this.value = this.states.includes(state) ? normalizedYAxis : 0.5;\n        break;\n\n      case MotionControllerConstants.ComponentProperty.BUTTON:\n        this.value = this.states.includes(state) ? button : 0;\n        break;\n\n      case MotionControllerConstants.ComponentProperty.STATE:\n        if (this.valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY) {\n          this.value = this.states.includes(state);\n        } else {\n          this.value = this.states.includes(state) ? 1.0 : 0.0;\n        }\n\n        break;\n\n      default:\n        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);\n    }\n  }\n\n}\n\nclass Component {\n  /**\n   * @param {Object} componentId - Id of the component\n   * @param {Object} componentDescription - Description of the component to be created\n   */\n  constructor(componentId, componentDescription) {\n    if (!componentId || !componentDescription || !componentDescription.visualResponses || !componentDescription.gamepadIndices || Object.keys(componentDescription.gamepadIndices).length === 0) {\n      throw new Error('Invalid arguments supplied');\n    }\n\n    this.id = componentId;\n    this.type = componentDescription.type;\n    this.rootNodeName = componentDescription.rootNodeName;\n    this.touchPointNodeName = componentDescription.touchPointNodeName; // Build all the visual responses for this component\n\n    this.visualResponses = {};\n    Object.keys(componentDescription.visualResponses).forEach(responseName => {\n      const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);\n      this.visualResponses[responseName] = visualResponse;\n    }); // Set default values\n\n    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);\n    this.values = {\n      state: MotionControllerConstants.ComponentState.DEFAULT,\n      button: this.gamepadIndices.button !== undefined ? 0 : undefined,\n      xAxis: this.gamepadIndices.xAxis !== undefined ? 0 : undefined,\n      yAxis: this.gamepadIndices.yAxis !== undefined ? 0 : undefined\n    };\n  }\n\n  get data() {\n    const data = {\n      id: this.id,\n      ...this.values\n    };\n    return data;\n  }\n  /**\n   * @description Poll for updated data based on current gamepad state\n   * @param {Object} gamepad - The gamepad object from which the component data should be polled\n   */\n\n\n  updateFromGamepad(gamepad) {\n    // Set the state to default before processing other data sources\n    this.values.state = MotionControllerConstants.ComponentState.DEFAULT; // Get and normalize button\n\n    if (this.gamepadIndices.button !== undefined && gamepad.buttons.length > this.gamepadIndices.button) {\n      const gamepadButton = gamepad.buttons[this.gamepadIndices.button];\n      this.values.button = gamepadButton.value;\n      this.values.button = this.values.button < 0 ? 0 : this.values.button;\n      this.values.button = this.values.button > 1 ? 1 : this.values.button; // Set the state based on the button\n\n      if (gamepadButton.pressed || this.values.button === 1) {\n        this.values.state = MotionControllerConstants.ComponentState.PRESSED;\n      } else if (gamepadButton.touched || this.values.button > MotionControllerConstants.ButtonTouchThreshold) {\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED;\n      }\n    } // Get and normalize x axis value\n\n\n    if (this.gamepadIndices.xAxis !== undefined && gamepad.axes.length > this.gamepadIndices.xAxis) {\n      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];\n      this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis;\n      this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis; // If the state is still default, check if the xAxis makes it touched\n\n      if (this.values.state === MotionControllerConstants.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > MotionControllerConstants.AxisTouchThreshold) {\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED;\n      }\n    } // Get and normalize Y axis value\n\n\n    if (this.gamepadIndices.yAxis !== undefined && gamepad.axes.length > this.gamepadIndices.yAxis) {\n      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];\n      this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis;\n      this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis; // If the state is still default, check if the yAxis makes it touched\n\n      if (this.values.state === MotionControllerConstants.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > MotionControllerConstants.AxisTouchThreshold) {\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED;\n      }\n    } // Update the visual response weights based on the current component data\n\n\n    Object.values(this.visualResponses).forEach(visualResponse => {\n      visualResponse.updateFromComponent(this.values);\n    });\n  }\n\n}\n/**\n * @description Builds a motion controller with components and visual responses based on the\n * supplied profile description. Data is polled from the xrInputSource's gamepad.\n * @author Nell Waliczek / https://github.com/NellWaliczek\n */\n\n\nclass MotionController {\n  /**\n   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around\n   * @param {Object} profile - The best matched profile description for the supplied xrInputSource\n   * @param {Object} assetUrl\n   */\n  constructor(xrInputSource, profile, assetUrl) {\n    if (!xrInputSource) {\n      throw new Error('No xrInputSource supplied');\n    }\n\n    if (!profile) {\n      throw new Error('No profile supplied');\n    }\n\n    this.xrInputSource = xrInputSource;\n    this.assetUrl = assetUrl;\n    this.id = profile.profileId; // Build child components as described in the profile description\n\n    this.layoutDescription = profile.layouts[xrInputSource.handedness];\n    this.components = {};\n    Object.keys(this.layoutDescription.components).forEach(componentId => {\n      const componentDescription = this.layoutDescription.components[componentId];\n      this.components[componentId] = new Component(componentId, componentDescription);\n    }); // Initialize components based on current gamepad state\n\n    this.updateFromGamepad();\n  }\n\n  get gripSpace() {\n    return this.xrInputSource.gripSpace;\n  }\n\n  get targetRaySpace() {\n    return this.xrInputSource.targetRaySpace;\n  }\n  /**\n   * @description Returns a subset of component data for simplified debugging\n   */\n\n\n  get data() {\n    const data = [];\n    Object.values(this.components).forEach(component => {\n      data.push(component.data);\n    });\n    return data;\n  }\n  /**\n   * @description Poll for updated data based on current gamepad state\n   */\n\n\n  updateFromGamepad() {\n    Object.values(this.components).forEach(component => {\n      component.updateFromGamepad(this.xrInputSource.gamepad);\n    });\n  }\n\n}\n\nexport { MotionController, MotionControllerConstants, fetchProfile, fetchProfilesList };\n"]},"metadata":{},"sourceType":"module"}